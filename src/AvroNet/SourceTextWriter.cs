using AvroNet.Schemas;
using Microsoft.CodeAnalysis.CSharp;
using System.CodeDom.Compiler;
using System.Text.Json;

namespace AvroNet;

internal sealed class SourceTextWriter : IDisposable
{
    private readonly StringWriter _stream;
    private readonly IndentedTextWriter _writer;
    private readonly AvroModelOptions _options;
    private readonly Dictionary<ReadOnlyMemory<byte>, AvroSchema> _schemas;

    public SourceTextWriter(AvroModelOptions options)
    {
        _stream = new StringWriter();
        _writer = new IndentedTextWriter(_stream, AvroGenerator.TabString);
        _options = options;
        _schemas = new(new ReadOnlyMemoryComparer());
    }

    public void Write(AvroSchema schema)
    {
        _writer.WriteLine(AvroGenerator.AutoGeneratedComment);
        if (_options.UseNullableReferenceTypes)
            _writer.WriteLine("#nullable enable");
        if (_options.UseFileScopedNamespaces)
        {
            _writer.WriteLine($"namespace {_options.Namespace};");
            _writer.WriteLine();
            WriteSchema(schema);
        }
        else
        {
            _writer.WriteLine($"namespace {_options.Namespace}");
            _writer.WriteLine("{");
            ++_writer.Indent;
            WriteSchema(schema);
            --_writer.Indent;
            _writer.WriteLine("}");
        }
        if (_options.UseNullableReferenceTypes)
            _writer.WriteLine("#nullable restore");
    }

    private void WriteSchema(AvroSchema schema)
    {
        var rawValue = schema.Name.GetRawValue();
        if (_schemas.ContainsKey(rawValue))
            return;

        switch (schema.GetTypeTag(_schemas))
        {
            case SchemaTypeTag.Null:
            case SchemaTypeTag.Boolean:
            case SchemaTypeTag.Int:
            case SchemaTypeTag.Long:
            case SchemaTypeTag.Float:
            case SchemaTypeTag.Double:
            case SchemaTypeTag.Bytes:
            case SchemaTypeTag.String:
            case SchemaTypeTag.Logical:
                return;

            case SchemaTypeTag.Array:
                WriteSchema(schema.AsArraySchema().ItemsSchema);
                return;

            case SchemaTypeTag.Map:
                WriteSchema(schema.AsMapSchema().ValuesSchema);
                return;

            case SchemaTypeTag.Union:
                var unionSchema = schema.AsUnionSchema();
                foreach (var member in unionSchema.Schemas)
                    WriteSchema(member);
                return;

            case SchemaTypeTag.Enumeration:
                _schemas[rawValue] = schema;
                WriteEnumSchema(schema.AsEnumSchema());
                return;

            case SchemaTypeTag.Fixed:
                _schemas[rawValue] = schema;
                WriteFixedSchema(schema.AsFixedSchema());
                return;

            case SchemaTypeTag.Record:
                _schemas[rawValue] = schema;
                var recordSchema = schema.AsRecordSchema();
                foreach (var field in recordSchema.Fields)
                    WriteSchema(field.Schema);
                WriteRecordSchema(recordSchema);
                return;

            case SchemaTypeTag.Error:
                _schemas[rawValue] = schema;
                var errorSchema = schema.AsErrorSchema();
                foreach (var field in schema.AsErrorSchema().Fields)
                    WriteSchema(field.Schema);
                WriteErrorSchema(errorSchema);
                return;

            default:
                throw new InvalidOperationException($"Unable to add name for schema '{schema.Name}' of type '{schema.GetTypeTag(_schemas)}'");
        }
    }

    private void WriteComment(JsonElement? documentation)
    {
        var comment = documentation?.GetString();
        if (!string.IsNullOrWhiteSpace(comment))
        {
            _writer.WriteLine("/// <summary>");
            _writer.Write("/// ");
            var span = comment.AsSpan();
            for (int i = 0; i < span.Length; ++i)
            {
                switch (span[i])
                {
                    case '\r':
                        break;
                    case '\n':
                        _writer.WriteLine();
                        _writer.Write("/// ");
                        break;
                    default:
                        _writer.Write(span[i]);
                        break;
                }
            }
            _writer.WriteLine();
            _writer.WriteLine("/// </summary>");
        }
    }

    private void WriteDefinitionStart(string typeDefinition, string typeIdentifier, string? baseTypeIdentifier = null)
    {
        _writer.WriteLine($"[{AvroGenerator.GeneratedCodeAttribute}]");
        if (baseTypeIdentifier is not null)
            _writer.WriteLine($"{_options.AccessModifier} {typeDefinition} {typeIdentifier} : {baseTypeIdentifier}");
        else
            _writer.WriteLine($"{_options.AccessModifier} {typeDefinition} {typeIdentifier}");
        _writer.WriteLine('{');
        ++_writer.Indent;
    }

    private void WriteDefinitionEnd()
    {
        --_writer.Indent;
        _writer.WriteLine('}');
    }

    private void WriteSchemaProperty(JsonElement json, string typeName, bool isOverride)
    {
        var schemaJson = typeName == _options.Name ? AvroGenerator.AvroClassSchemaConstName : SymbolDisplay.FormatLiteral(json.GetRawText(), quote: true);
        _writer.WriteLine($"public static readonly {AvroGenerator.AvroSchemaTypeName} _SCHEMA = {AvroGenerator.AvroSchemaTypeName}.Parse({schemaJson});");
        _writer.WriteLine($$"""public {{(isOverride ? "override " : "")}}{{AvroGenerator.AvroSchemaTypeName}} Schema { get => {{typeName}}._SCHEMA; }""");
    }

    private void WriteField(FieldInfo field)
    {
        WriteComment(field.Schema.Documentation);

        var modifiers = !field.Type.IsNullable && _options.UseRequiredProperties ? "public required" : "public";
        var set = _options.UseInitOnlyProperties ? "init" : "set";
        var defaultValue = field.Type.GetValue(field.Schema.Default);
        if (!field.Type.IsNullable && _options.UseNullableReferenceTypes)
            defaultValue ??= "default!";

        if (defaultValue is not null)
            _writer.WriteLine($$"""{{modifiers}} {{field.Type}} {{field.Name}} { get; {{set}}; } = {{defaultValue}};""");
        else
            _writer.WriteLine($$"""{{modifiers}} {{field.Type}} {{field.Name}} { get; {{set}}; }""");
    }

    private readonly record struct FieldInfo(FieldSchema Schema, string Name, TypeSymbol Type, int Position);

    private void WriteGetMethod(List<FieldInfo> fields, bool isOverride)
    {
        var objectType = _options.UseNullableReferenceTypes ? "object?" : "object";
        _writer.WriteLine($"public {(isOverride ? "override " : "")}{objectType} Get(int fieldPos)");
        _writer.WriteLine("{");
        ++_writer.Indent;
        _writer.WriteLine("switch (fieldPos)");
        _writer.WriteLine("{");
        ++_writer.Indent;
        foreach (var field in fields)
            _writer.WriteLine($"case {field.Position}: return this.{field.Name};");
        _writer.WriteLine("""default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Get()");""");
        --_writer.Indent;
        _writer.WriteLine("}");
        --_writer.Indent;
        _writer.WriteLine("}");
    }

    private void WritePutMethod(string ownerTypeName, List<FieldInfo> fields, bool isOverride)
    {
        var objectType = _options.UseNullableReferenceTypes ? "object?" : "object";
        _writer.WriteLine($"public {(isOverride ? "override " : "")}void Put(int fieldPos, {objectType} fieldValue)");
        _writer.WriteLine("{");
        ++_writer.Indent;
        _writer.WriteLine("switch (fieldPos)");
        _writer.WriteLine("{");
        ++_writer.Indent;
        var parameterName = _options.UseNullableReferenceTypes ? "fieldValue!" : "fieldValue";
        if (_options.UseInitOnlyProperties)
        {
            var setPrefix = _options.UseUnsafeAccessors ? "" : $"{ownerTypeName}Reflection.";
            foreach (var field in fields)
                _writer.WriteLine($"case {field.Position}: {setPrefix}Set_{field.Name}(this, ({field.Type}){parameterName}); break;");
        }
        else
        {
            foreach (var field in fields)
                _writer.WriteLine($"case {field.Position}: this.{field.Name} = ({field.Type}){parameterName}; break;");
        }
        _writer.WriteLine("""default: throw new global::Avro.AvroRuntimeException($"Bad index {fieldPos} in Put()");""");
        --_writer.Indent;
        _writer.WriteLine("}");

        if (_options.UseInitOnlyProperties && _options.UseUnsafeAccessors)
        {
            foreach (var field in fields)
            {
                _writer.WriteLine($"""[global::System.Runtime.CompilerServices.UnsafeAccessor(global::System.Runtime.CompilerServices.UnsafeAccessorKind.Method, Name = "set_{field.Name}")]""");
                _writer.WriteLine($"extern static void Set_{field.Name}({ownerTypeName} obj, {field.Type} value);");
            }
        }

        --_writer.Indent;
        _writer.WriteLine("}");

        if (_options.UseInitOnlyProperties && !_options.UseUnsafeAccessors)
        {
            _writer.WriteLine($"private static class {ownerTypeName}Reflection");
            _writer.WriteLine("{");
            ++_writer.Indent;

            foreach (var field in fields)
                _writer.WriteLine($"""public static readonly Action<{ownerTypeName}, {field.Type}> Set_{field.Name} = CreateSetter<{field.Type}>("{field.Name}");""");

            _writer.WriteLine($"private static Action<{ownerTypeName}, TProperty> CreateSetter<TProperty>(string propertyName)");
            _writer.WriteLine("{");
            ++_writer.Indent;
            _writer.WriteLine($"""var objParam = global::System.Linq.Expressions.Expression.Parameter(typeof({ownerTypeName}), "obj");""");
            _writer.WriteLine($"""var valueParam = global::System.Linq.Expressions.Expression.Parameter(typeof(TProperty), "value");""");
            if (_options.UseNullableReferenceTypes)
                _writer.WriteLine($"""var property = global::System.Linq.Expressions.Expression.Property(objParam, typeof({ownerTypeName}).GetProperty(propertyName)!);""");
            else
                _writer.WriteLine($"""var property = global::System.Linq.Expressions.Expression.Property(objParam, typeof({ownerTypeName}).GetProperty(propertyName));""");
            _writer.WriteLine($"""var assign = global::System.Linq.Expressions.Expression.Assign(property, valueParam);""");
            _writer.WriteLine($"""var lambda = global::System.Linq.Expressions.Expression.Lambda<Action<{ownerTypeName}, TProperty>>(assign, objParam, valueParam);""");
            _writer.WriteLine($"""return lambda.Compile();""");
            --_writer.Indent;
            _writer.WriteLine("}");

            --_writer.Indent;
            _writer.WriteLine("}");
        }
    }

    private void WriteRecordSchema(RecordSchema schema)
    {
        var name = Identifier.GetValid(schema.Name);

        WriteComment(schema.Documentation);
        WriteDefinitionStart(_options.DeclarationType, name, AvroGenerator.AvroISpecificRecordTypeName);
        WriteSchemaProperty(schema.Json, name, isOverride: false);

        var fields = schema.Fields
            .Select((field, index) => new FieldInfo(
                field,
                Identifier.GetValid(field.Name),
                TypeSymbol.FromSchema(field.Schema, nullable: false, _schemas, _options),
                index))
            .ToList();

        foreach (var field in fields)
            WriteField(field);

        WriteGetMethod(fields, isOverride: false);
        WritePutMethod(name, fields, isOverride: false);

        WriteDefinitionEnd();
        _writer.WriteLine();
    }

    private void WriteErrorSchema(ErrorSchema schema)
    {
        var name = Identifier.GetValid(schema.Name);

        WriteComment(schema.Documentation);
        WriteDefinitionStart(_options.DeclarationType, name, AvroGenerator.AvroSpecificExceptionTypeName);
        WriteSchemaProperty(schema.Json, name, isOverride: true);

        var fields = schema.Fields
            .Select((field, index) => new FieldInfo(
                field,
                Identifier.GetValid(field.Name),
                TypeSymbol.FromSchema(field.Schema, nullable: false, _schemas, _options),
                index))
            .ToList();

        foreach (var field in fields)
            WriteField(field);

        WriteGetMethod(fields, isOverride: true);
        WritePutMethod(name, fields, isOverride: true);

        WriteDefinitionEnd();
        _writer.WriteLine();
    }

    private void WriteEnumSchema(EnumSchema schema)
    {
        WriteComment(schema.Documentation);
        var name = Identifier.GetValid(schema.Name);
        WriteDefinitionStart("enum", name);
        foreach (var field in schema.Symbols)
        {
            _writer.Write(Identifier.GetValid(field));
            _writer.WriteLine(',');
        }
        WriteDefinitionEnd();
        _writer.WriteLine();
    }

    private void WriteFixedSchema(FixedSchema schema)
    {
        WriteComment(schema.Documentation);
        var name = Identifier.GetValid(schema.Name);
        WriteDefinitionStart("partial class", name, AvroGenerator.AvroSpecificFixedTypeName);
        WriteSchemaProperty(schema.Json, name, isOverride: true);
        _writer.WriteLine($$"""public uint FixedSize { get => {{schema.Size}}; }""");
        _writer.WriteLine($"public {name}() : base({schema.Size})");
        _writer.WriteLine("{");
        ++_writer.Indent;
        _writer.WriteLine($"(({AvroGenerator.AvroGenericFixedTypeName})this).Schema = ({AvroGenerator.AvroFixedSchemaTypeName}){name}._SCHEMA;");
        --_writer.Indent;
        _writer.WriteLine("}");
        WriteDefinitionEnd();
        _writer.WriteLine();
    }

    public override string ToString() => _stream.ToString();

    public void Dispose()
    {
        _stream.Dispose();
        _writer.Dispose();
    }
}
